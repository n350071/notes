# 伴走支援する開発会社の目利きGPTの補足資料.md
## アジャイルソフトウェア開発宣言
私たちは、ソフトウェア開発の実践
あるいは実践を手助けをする活動を通じて、
よりよい開発方法を見つけだそうとしている。
この活動を通して、私たちは以下の価値に至った。

プロセスやツールよりも個人と対話を、
包括的なドキュメントよりも動くソフトウェアを、
契約交渉よりも顧客との協調を、
計画に従うことよりも変化への対応を、

価値とする。すなわち、左記のことがらに価値があることを
認めながらも、私たちは右記のことがらにより価値をおく。

## アジャイル宣言の背後にある原則
私たちは以下の原則に従う:

- 顧客満足を最優先し、価値のあるソフトウェアを早く継続的に提供します。
- 要求の変更はたとえ開発の後期であっても歓迎します。変化を味方につけることによって、お客様の競争力を引き上げます。
- 動くソフトウェアを、2-3週間から2-3ヶ月というできるだけ短い時間間隔でリリースします。
- ビジネス側の人と開発者は、プロジェクトを通して日々一緒に働かなければなりません。
- 意欲に満ちた人々を集めてプロジェクトを構成します。環境と支援を与え仕事が無事終わるまで彼らを信頼します。
- 情報を伝えるもっとも効率的で効果的な方法はフェイス・トゥ・フェイスで話をすることです。
- 動くソフトウェアこそが進捗の最も重要な尺度です。
- アジャイル･プロセスは持続可能な開発を促進します。一定のペースを継続的に維持できるようにしなければなりません。
- 技術的卓越性と優れた設計に対する不断の注意が機敏さを高めます。
- シンプルさ（ムダなく作れる量を最大限にすること）が本質です。
- 最良のアーキテクチャ・要求・設計は、自己組織的なチームから生み出されます。
- チームがもっと効率を高めることができるかを定期的に振り返り、それに基づいて自分たちのやり方を最適に調整します。

## アジャイル勘違い集
アジャイル勘違い集
(ジェーアイシー)桑折誠太郎、   (タワーズ・クエスト)和田卓人
(永和システムマネジメント)
        天野勝、家永英治、角谷信太郎、懸田剛、田中里実、安井力
編集：(翔泳社)佐藤善昭
巷で流行りのアジャイル。取り入れてみたいけれども不安がいっぱい、取り入れてはみたもののうまく行かない、そんなことを考えてはいませんか？ 正しいアジャイルって何でしょう。ここでは、みなさんのそんな質問にお応えします。

アジャイル勘違い集(2014年版)
1.	アジャイルは誰でもできる？
2.	デキる人じゃないと無理？
3.	ドキュメントを書かない？
4.	コミュニケーションには呑み会が適している？
5.	設計はなるべくしない？
6.	アジャイルとアジャイルプロセスは同じ？
7.	プラクティスこそが大事？
8.	いつでも仕様変更OK？
9.	テスターは必要ない？
10.	リファクタリングは危険？
11.	ペアプロすると眠くなる？
1.	アジャイルは誰でもできる？
Q.	アジャイルって、やる気さえあれば誰でもできるんですよね！
A.	やる気さえあればできるというのは、ある意味では正しいのですが、盲目にそう信じてしまうと痛い目を見ることになるでしょう。 アジャイルな手法は、変化に対応したり、コミュニケーションをとったり、改善を模索したりという行動を要求します。 そうした行動が苦手な人や嫌いな人は、アジャイル手法が苦痛になってしまうかもしれません。 さらにそういう人はアジャイル手法に対して意識的・無意識的に抵抗して、チーム全体の足を引っ張ることさえあります。 アジャイルに向いた人もいれば、重厚な方法論に向いた人もいます。向き不向きを考えてメンバーを集めるか、 メンバーが固定しているプロジェクトではそのメンバーに向いたやり方を考えたりしましょう。それがプロジェクト成功の早道です。
▲ページTOPへ
2.	デキる人じゃないと無理？
Q.	アジャイルって、デキる人・優秀な人・ベテランにしかできないんじゃないの？
A.	デキる人ならアジャイルができるとは限りません。Q1.にあるように、技術スキルではなく行動の仕方で、アジャイルに向く向かないが変わります。
私見ですが、「あの人にプログラム任せると完璧なんだよね」とか「Webサービスのことならなんでも知ってるよ」と言われるような、 技術力の高い熟練者には、アジャイルに向かない人が多いようです。作業範囲を個人で厳密に区切ったり、手順をキチッと決めて作業したり、 自分の作業を邪魔されるのを嫌ったりするためではないかと思います。
また、技術的には未熟でもアジャイルのやり方になじめれば、プロジェクトの中で飛躍的に成長するチャンスがあります。 アジャイルなプロジェクトでは、いろいろな作業を担当したり、人の技から学んだり、間違いを指摘されたりするチャンスが豊富にあります。 決められた作業だけをやるよりもはるかに早く成長して、プロジェクトの戦力となれる可能性が大きいのです。
▲ページTOPへ
3.	ドキュメントを書かない？
Q.	アジャイルプロセスはドキュメントを書かないと聞きました。そんなプロセスは不安で採用できませんよ。
A.	「アジャイルプロセスはドキュメントを書かない」と最初に言ったのは誰なのでしょうか。正直、迷惑してます。 もちろんアジャイルプロセスでもドキュメントは書きます。ただ優先順位が異なるだけです。 『アジャイルソフトウェア開発宣言』にもあるように「完全なドキュメントよりも、動くソフトウェア」を相対的に重視するだけです。 最小限の文書化で最大限の効果を狙う、必要にして十分なドキュメント。そうしたドキュメントは一朝一夕に書けるものではありません。 むしろアジャイルプロセスのほうが、ドキュメント作成の難易度は高いともいえます。 「コードがドキュメントだ」とうそぶくことは簡単ですが、「ドキュメントであるかのようなコード」「ドキュメントが不要なコード」を書くのはとても難しいです。 また、コードだけでは「なぜこの設計にしたのか」「なぜ他の設計にしなかったのか」という設計判断の根拠が残せません。 アジャイルプロセスはコードを重視するプロセスではあっても、偏重するプロセスではありません。 コードとドキュメントの間でバランスを取ってこそのアジャイルプロセスなのです。
▲ページTOPへ
4.	コミュニケーションには呑み会が適している？
Q.	メンバー間でコミュニケーションがうまく行われていないように感じています。これではいけないと思い、メンバーを呑み会に誘うようにしています。 毎回ほとんど全員が参加してくれて、その場は楽しく過ごすのですが、次の朝になるとまた以前と変わらない雰囲気です。なにか、アドバイスをください。
A.	日本には昔から「呑みにけーしょん」という言葉があるように、コミュニケーションの改善の場を、 呑み会のようなインフォーマルな場(職場外、就業時間外)に設けることがよく行われていました。 しかし、コミュニケーションの基本は「信頼」です。呑み会の場で、自己開示を行ったり、相手に関心を示したりするのも大事ですが、 まずはフォーマルな場での解決を考えるべきでしょう。
また、状況を改善するためには、相手を変えるのではなく自分が変わるという意識が重要です。 普段から、「約束は守る」「人の話を最後まで聞く」「大事なことは即座に報告する」などを心がけるようにしましょう。
▲ページTOPへ
5.	設計はなるべくしない？
Q.	XPの「シンプル」を実践し、表記法などを使った設計に時間をかけずにプログラミングに注力しました。 すると、ソフトウェアの複雑さが増大し、手がつけられなくなりました。どうしたらいいですか？
A.	「シンプル」は過剰なアーキテクチャ重視を批判していますが、「設計をまったく行わない」のではありません。 「UMLを使ったモデリングだけが設計だ」と狭義に考えずに、TDDとリファクタリングを使った「設計」を採用して、 ソフトウェアの複雑さに対応してはいかかでしょうか。
TDDとリファクタリングは、モデル→コードといった演繹中心に良いソフトウェア構造を振舞いを導きだす代わりに、 試行錯誤によって段階的に導き出すアプローチを提案しています。
プログラミング前に、UMLやその他の手法を用いたモデリングセッションを設けてはいかがでしょうか。 ただし、1週間以上一人でモデリングツールをちょこちょこ触っているようなことは避けてください。 顧客価値をもたらさない自己満足を満たすためや知的権力を誇示するためにパターンを採用していないか注意してください。
まずは、半日ぐらいの時間でホワイトボードや付箋といった道具を使ったグループディスカッションがお勧めです。
▲ページTOPへ
6.	アジャイルとアジャイルプロセスは同じ？
Q.	アジャイルで開発していますが、うまくいきません。どうすればうまく行くのでしょうか？
A.	あなたが用いているのはアジャイルではなく、アジャイルプロセスではありませんか？ アジャイルプロセスとは、XPやスクラムに代表される「アジャイルな開発を実践するために、重要なプラクティスを定義し、まとめたもの」です。 このアジャイルプロセスを忠実に実践しているだけでは、ソフトウエア開発はうまく行きません。 優れたプラクティスを忠実に実践すれば効果を生むこともありますが、その価値と原則を知らなければ、本来の力を発揮することはできません。
アジャイルとは、ソフトウエア開発に対する、心の持ちようや、取り組む態度をあらわした言葉です。 アジャイルプロセスによる開発を成功させるためには、アジャイル提唱者達が宣言した4つの価値とそこから導き出された12の原則を常に心に留め置く必要があります。
▲ページTOPへ
7.	プラクティスこそが大事？
Q.	プラクティスを実践すればアジャイル開発をやっていると言えるんですよね？今日も上司にアジャイルのプラクティスの重要性を訴えてきましたよ！！
A.	確かに、プラクティスは具体的な実践項目であり、導入のスタートラインになるでしょう。しかしプラクティスを実践することがゴールではありません。 プラクティスは必ず「原則」に基づいて実施されます。原則は「価値」を、妥当であるかどうかの判断基準としています。
まずプラクティスから始めてください。そして次に、あなたの環境に合わせてプラクティスをカスタマイズしてください。 その時に、「原則」に則っているか、「価値」に合っているのかを考えてみてください。 もっと簡単に言えば「なぜ、そのプラクティスを実践するのか」を深く考えてみてください。
プラクティスについて深く考え、その背景にある「原則」「価値」そして「理由」が見えた時、あなたはプラクティスの真の価値に気付いたことになります。
▲ページTOPへ
8.	いつでも仕様変更OK？
Q.	いつでも仕様変更できると思って、アジャイル開発を始めました。なのに、仕様変更がある度に激務になります。 仕様変更に機敏に対応できることがアジャイル開発ではなかったですか？
A.	アジャイル開発だからといって、むやみに仕様の変更を受け入れてはいないでしょうか？そもそも、それは本当に仕様"変更"ですか？ ユーザにも理解してもらい、必要な機能のみを組み込みましょう。変更反映のタイミングも重要です。 各イテレーションでリリースした製品をユーザに評価してもらい、その結果を次のイテレーションで反映するようにしましょう。
また、テストは正しく行えていますか。テストは仕様を現します。テストファーストであれば、仕様変更と思われがちな"仕様の誤認"を防ぐことができます。 すべての機能に対するテストが記述されていれば、安全なリファクタリングも可能になります。 ソースコードをシンプルで美しくすることで、コードの可読性が高まり、仕様変更を受け入れやすくなるでしょう。
▲ページTOPへ
9.	テスターは必要ない？
Q.	アジャイル開発を行えば品質が高まるなら、テスターは必要ないのではないですか？
A.	結論から言うと品質保証のためのテスト行程、およびテスターは必要です。
アジャイル開発、特にテストを重視するプロセスを実施する場合には、テストがみっちりと行われるためテスターは必要ないのではないかと言う方がいます。 しかし、品質保証のためのテストと開発促進のためのテストは異なります。
非機能用件に関してはお客さまは素人です。そしてプログラマもまた、非機能用件に関しては不十分な知識しか持っていないこともあります。 たとえプログラマーがテスターを兼任することになっても、品質保証の視点からのテストを行う必要があるでしょう。 アジャイル開発が対象にしているテストは開発促進のためのテストであって、品質保証のためのテストではありません。
▲ページTOPへ
10.	リファクタリングは危険？
Q.	リファクタリングしたら、いままで動いていたものが壊れてしまいました。 やはり、「動いているものには触るな」のアドバイスに従ったほうがいいと思うのですが。
A.	壊れてしまうようでは「リファクタリング」とは呼べません。テストファーストやTDDと組み合わせて、 動作を確認をしながら安全にリファクタリングを行いましょう。また、リファクタリングツールを使って、作業を機械に任せましょう。 もし誤っても、バージョン管理ツールで動いている状態に戻せるようにします。ペアプロやコードレビューと組み合わせて、安全にリファクタリングを行いましょう。
▲ページTOPへ
11.	ペアプロすると眠くなる？
Q.	ペアプログラミングでナビゲータになると、手持ち無沙汰で眠くなります。なにか良い方法はありませんか？
A.	ペアプログラミングは、ドライバーとナビゲータの双方が知力を合わせてプログラミングを行います。
ナビゲータは、ドライバーといっしょにプログラムを考えてください。そして、たくさんアイデアを出してください。 分かりにくいコードをドライバーが書いたときは、すぐに説明を求めましょう。 そうすれば手持ち無沙汰にならずに、とてもエキサイティングな時間をすごせると思いますよ。
そういえば、ペアプロがらみでこんな勘違いな話を聞いたのを思い出しました。
ナビゲータがプログラムを考え、ドライバーは打ち込むだけ。ドライバーをしている間は、プログラムを考えてはいけない。 どうやら、ラリーのドライバーとナビゲータのメタファを使っているようです。 ドライバーは、どこに向かうかはナビゲータの指示に絶対服従しなくてはならないと思っていたようです。ちょっと、玄人レベルの勘違いですかね。

## ヘロヘロスクラム
### 原文
There's a mess I've heard about with quite a few projects recently. It works out like this:

They want to use an agile process, and pick Scrum
They adopt the Scrum practices, and maybe even the principles
After a while progress is slow because the code base is a mess
What's happened is that they haven't paid enough attention to the internal quality of their software. If you make that mistake you'll soon find your productivity dragged down because it's much harder to add new features than you'd like. You've taken on a crippling TechnicalDebt and your scrum has gone weak at the knees. (And if you've been in a real scrum, you'll know that's a Bad Thing.)

I've mentioned Scrum because when we see this problem, Scrum seems to be particularly common as the nominative process the team is following. For many people, this situation is exacerbated by Scrum because Scrum is process that's centered on project management techniques and deliberately omits any technical practices, in contrast to (for example) Extreme Programming.

In defense of Scrum, it's important to point out that just because it doesn't include technical activities within its scope should not lead anyone to conclude that it doesn't think they are important. Whenever I've listened to prominent Scrummers they've always emphasized that you must have good technical practices to succeed with a Scrum project. They don't mandate what those technical practices should be, but you do need them. After all projects get into trouble for poor internal quality all the time, the fact that a lot crop up under Scrum's flag may be more due to the fact that Scrum is so popular at the moment then anything particular to Scrum. Popularity and SemanticDiffusion tend to go together.

So what to do about it?

The scrum community needs to redouble its efforts to ensure that people understand the importance of strong technical practices. Certainly any kind of project review should include examining what kinds of technical practices are present. If you're involved or connected to such a project, make a fuss if the technical side is being neglected.

If you're looking to introduce scrum, make sure you pay good attention to technical practices. We tend to apply many of those from Extreme Programming and they fit just fine. XPers often joke, with some justification, that Scrum is just XP without the technical practices that make it work. Sniping aside, the XP practices make a good starting point - and are certainly going to be much better than doing nothing at all.

I always like to point out that it isn't methodologies that succeed or fail, it's teams that succeed or fail. Taking on a process can help a team raise its game, but in the end it's the team that matters and carries the responsibility to do what works for them. I'm sure that the many Flaccid Scrum projects being run will harm Scrum's reputation, and probably the broader agile reputation as well. But since I see SemanticDiffusion as an inevitability I'm not unduly alarmed. Teams that fail will probably fail whatever methodology they mis-apply, teams that succeed will build their practices on good ideas and the scrum community's role is to spread these good ideas around widely.

Many people are looking to Lean as the Next Big Agile Thing. But the more popular lean becomes the more it will run into the same kind of issues as Scrum is facing now. That doesn't make Lean (or Scrum) worthless, it just reminds us Individuals and Interactions are more valuable than Processes and Tools.

### 感想
これはソフトウェアの内部品質に彼らが気を配っていなかったことが原因だ。
Scrumはプロジェクト管理の技術をその中心に据えたプロセスである。技術的プラクティスを意図的に追いやってしまっている。
	Scrumを擁護しておくと、技術的アクティビティをそのスコープに入れていないというだけで、それを重要だと考えなくてもいい、ということにはなっていない。
Scrumが導入されるときは、技術的プラクティスに十分に注意を払おう。
感想：技術的プラクティスをおざなりにするとヘロヘロになるのか！

## 「それ、アジャイルできてへんのちゃいますか？」チェックリスト
1. 進化型設計ができていない
　アジャイル開発を実施するということは、単に繰り返し型で開発すればいいものではない。アジャイルは「変化に対応する」ことが大きな目的の一つになっている。スプリントや、イテレーションで繰り返し型の開発を行う場合、繰り返し型で開発を行って、変化があっても、メンテナンスを実施しやすいコードベースをキープしないといけない。 　そうでなければ、早晩、プロジェクトはメンテ不可能になって破たんする。スプリントを通して、変化を受け入れても、メンテ可能な状態を保つには、十分な自動実行できるユニットテストが書かれている事、変更があったときに、それが自動で検査されること、そして、設計が「変化前提」の方式になっているということが重要だ。

　こういったアジャイルにおける「テクニカルプラクティス」やその「マインドセット」を学ぶには、Extreme Programming を学ぶのが一番おすすめだ。更に高度なテクニカルプラクティスを学ぶには、DevOps のプラクティスを学ぶとよい。

　アジャイルは世界的にスクラムが最も流行っているが、スクラムの作者も、「テクニカルプラクティス」を軽視しているわけではない。確か、Ken Schwaber がQ&Aでこんなことを言っていた。

Q: スクラムを採用しているが、エンジニアリングがちゃんとできないメンバーだったらどうなりますか？

A: うん。10倍のスピードでものができるよ。ただしゴミだけどね。

　スクラムを回していても、ソフトウェアを開発しているケースでは、「テクニカルプラクティス」を無視してしまうと、非常に危険なこと になる。

1.1. テスト駆動開発
　まず、最初におすすめしたいのが、テスト駆動開発(Test Driven Development) もしくは、振る舞い駆動開発(Behavior Driven Development) で開発するのをおすすめしている。最先端での議論では、TDDは死んだと言っている向きもあり、すべてをそれで開発しなくてもいいが、このいづれかの開発スタイルが「やろうと思ったら出来る」ということは絶対的に重要だ。だから、これが「できない」と言っているアジャイルベンダーは「エセ」といっても差し支えない。変更があったら当然テストが必要だが、変更が当然のアジャイルで、変更の度に全量手動テストなんてやってられないだろう。

　十分な単体テストを書こうと思うときに、後追いで、ユニットテストのコードを書くと死ぬほど難しく、複雑になる。本番のコードは甘くないのだ。じゃあどうする かというと、少しだけ先に「テストコード」を書いて、テスト実行。エラーになったのを確認してから、本番コードを数行実装、テストを実行してパスしたら、次のテストコードの実装を少しだけ、、、更に、コードが重複したら「リファクタリング」という方法でコードの設計を改善する。 　このようなステップを踏んで開発をすると、常にテストコードが十分な状態で無理なく開発を進めることができる。イメージがわきやすいようにビデオを作成したので、参考にされるとよいかもしれない。１５分程度だ。



docs.com

1.2. 進化型設計　
　 　次に進化型設計。アジャイル以前の世界の設計の考え方は、Big Desgin Upfront という設計の方法だ。時間をかけて分析、設計を行って、そのあと実装やテストに入る方法だ。一方、アジャイル以降は、進化型設計と言われる方法をとっている。ソフトウェアエンジニアリングの技術、例えばデザインパターンなどの知識が変わるとかそういう話ではないが、設計の進め方が変わる感じだ。これは、次のようなパラダイムの変更が影響している。

f:id:simplearchitect:20160923162637p:plain

この図はExtreme Programmingから紹介された概念だ。１つの変更に対してどの程度変更のコストがかかるか？という図になっている。ウォータフォール開発時代は、一つの変更に対するコストは、後のフェーズに行けば行くほど指数関数的に高価になってしまっていた。例えば要件定義フェーズで問題を発見したら、要件定義書を直すだけだが、テストフェーズで発見したら、実装をおなして、設計書を書き直して、要件定義書を、、、といったように非常に高くついてしまう。 　だから、要件を固めよう！ということを一生懸命やっていたのだ。一方アジャイルの世界では、テスト駆動開発などで適切に自動テストが書かれており、継続的インテグレーションにより、それが常時結合されて、テストされており、なおかつ、「進化型設計」を用いて、変更が簡単にできるのであれば、開発の後半になっても一つの変更に対するコストがあまり変わらないという状態を創れるようになった。


f:id:simplearchitect:20160923163844j:plain

Big Design Upfront で設計している場合、最初の設計で想定していない変更が入ると、どんどん設計は崩れていく。そもそも、設計に長く時間をかけても、現在のソフトウェアは実装するまで本当のところがわからないケースが多いため、実装せずに設計するのは相当に難しいことだ。一方、進化型設計は、テスト駆動等を用いて、テストがある状態をキープしているので、変更を行っても、おかしくなったらすぐわかるし、DRY(Don't Repeat Yourself)をはじめとしたマインドセットでコードが作られていると、１箇所変えるだけで変更ができるので、こういった、コストカーブが実現できるようになる。だから変更に強くなる。

　ということは、そういうことをしていなかったら、いくらアジャイルっぽくスプリントを回したところで、ソフトウェアはその変更に耐えられなくなってしまう。だから、テスト駆動などの方法を学んで、常にクリーンコードを書くことを実践しないと、あなたのコードベースは遅かれ早かれメンテ不能に陥ってしまう。

マーチンファウラー氏の進化型設計のページ

　こういったことは、ツールをいくら導入しても解決できない。これは「開発の習慣」だから、本を読んでもすぐにできるわけでもない。じゃあどうするかというと、本当に「テスト駆動などの開発習慣を何年も当然として実施できる」メンバーを開発チームに入れるのだ。これは数カ月でもいい。本で読んでもすぐわからないかもしれないが、そういう「イケメン」と一緒に開発をすると、「あーこうだったのか！」と簡単に理解できる。ただ、こういう「技術イケメン」は普段あなたがお付き合いしているベンダーにはいないかもしれない。実際問題として、できないベンダーでも受注するために「できます！」というケースもあるし、自分が「できない」ことに気づいていないベンダーさんも多い。これを、一人で見分けるのは最初は難しいかもしれないが、シンプルな方法としては、アジャイル系のイベントに参加して、スポンサーセッション以外で登壇している人を捕まえて、その人に、「テスト駆動をホンマにできる人紹介してくれませんか？」とお願いしてみよう。そしたら、本当にそういうことができるベンダーさんを教えてくれるだろう。アジャイルができる人は、ちょっと話をしたら、誰がちゃんとできるかもわかるものだ。 　 もしくは、t-wadaという男を見つけて、彼にしっかりとした対価をお支払いするのがいいかもしれないw (注：TDDと言えばt-wadaと言われる日本のテスト駆動の大家ですw)


twitter.com

もちろん私に聞いてもらっても結構だ。

1.3. スプリントはミニウォーターフォールではない
　よくある誤解で、スプリントの内部はウォータフォールになっているというのがある。実際はそうではない。進化型設計で開発すると、「要件ー＞分析・設計ー＞実装ー＞テスト」という順番で物事は進まない。

f:id:simplearchitect:20160923170842j:plain

先ほどのテスト駆動開発だって、そもそも実装の前にテストであり、実装をした後にリファクタリングで「設計」変更を行う。進化型設計とは、常に設計をしているような状態だ。実際に実装してから、ユーザさんに見せると、「あーイメージが違うよ」となるかもしれない。それは要件を確認している行為だろう。 　つまりアジャイルの開発では、要件、分析、設計、実装、テストはいったり来たりする感じで開発されるので、シーケンシャルに流れるものではない。だから、もしそうなっていたら、ミニウォータフォールと呼ばれるバッドプラクティスに陥っている可能性が高い。これも、先ほどの「良い開発習慣を持った人をチームに雇う」ことが最も良い解決策だと思う。　

2. ビルドが中心になっていない
　次によくありがちな状態としては、開発のスケジュールが決まっていて、機能１を第一スプリントで、機能２を第二スプリントで、、というような形態になているケース。

f:id:simplearchitect:20160923164229j:plain

これは何が問題か？というと、アジャイルの考え方では、「動作するアプリケーションで物事を判断する」ということがある。例えば、機能１ができて、機能２ができてから、機能３を作ってやっとお客様に見せて価値があるとかいうスケージュールになっている場合が多い。でも、それだと、第三スプリントが終わるまで、仕掛品を作り続けていることになり大変危険だ。アジャイルの場合は、最初のスプリントから、価値の出る単位で、開発していこう。別に「最終製品」のクオリティが実装されていなくてもいい。 最初のうちに必要なのは、価値の出る単位ものが、つながってビルドとなっているかだ。仕掛品は、つなげてみるまで結局本当にできているかはわからない。だから小さくてもいいし、機能がフルに実装できてなくていいので、つながっているものを創っていく。最初に作ったものがそのまま本番に使われると考えるよりも、最初のものは、アーキテクチャ的だったり、仕様的だったり、どれが正しいかを探索する実験のようなものだ。工数をかけず、さっとつなげて、ビルドをつくって、そこからフィードバックを得よう。だから、がっつり機能１、機能２を実装していくなんてことは、本当にそれでよいかわからないものに対して多大な工数をかけていくことに他ならない。 それは大変アジャイルの世界では危険な行為なのだ。まずそれがそのプロジェクトにとって「正しいか」を確かめよう。最小の工数で。

3. 予定の機能の実現がMUSTになっている
　さらによくあるのが、予定の作業をすべて実装しようとしているケースである。アジャイルでやったからといって、自動的にウォーターフォールに対して生産性が強烈にアップするだろうか？ポイントは、「無駄なことをやらない」ことだ。すべての機能実装を100%やって、それを劇的に早める方式などない。

f:id:simplearchitect:20160923171235j:plain

　しかし、実際のところ、機能のうち、本当に使われるものは、40%未満だ。それを考えると、使われない機能を実装しないだけで、生産性は倍になる。多くの人は、「たくさん早く実装する」ことがよいと思っているかもしれないが、ポイントは、「やらないことを見つける」事だ。そのためにアジャイルでは「スプリント」をつかって学びを得て、いかに少ない工数で、より高い価値を提供するかを追求している。ものをたくさん生産したらたくさん価値が出るわけではない。だから、最初に予定している機能を100%実装するということは、無駄を大量に実装していることになり、そんなことをしたら、アジャイルで開発しても全然価値が出ないことになる。

　たくさん機能を実装したら、たくさん価値が出るという考えを捨てることから始めよう。


simplearchitect.hatenablog.com

　こういう「マインドセット」は、プロジェクトの開始前に関係者にプレゼンテーションなどをしてシェアするのをおすすめしている。後出しじゃんけんになると、反発してくる人も多く出てくるが、始まる前で、かつアジャイルを導入しよう！と会社で決めているならば、皆さん喜んで学ぼうとしてくれる。アジャイルコーチを採用して、こういう事を最初の段階から共有するようにしよう。「シンプルさ」に関するマインドセットもExtreme Programming から来たものだ。

Do The Simplest Thing That Could Possibly Work

You Arent Gonna Need It

Once And Only Once

4. マネージャーの指示でチームが動いている
　最後のアンチパターンとしては、マネージャの人が、スプリントでの実施内容を決めていたり、マネージャの指示にしたがって、メンバーが動いているようなケースだ。

f:id:simplearchitect:20160923164915j:plain

アジャイルの場合は「自己組織チーム」といわれる考えでチームを運用する。チームに技術的決定や、タスクの分割、割り当て、見積もり、、などなど大きく権限を与えて彼ら自身が考えて判断するようにする。DevOps の時代でもそれが進化したフィーチャーチームという考えになる。そこには開発チームだけではなく、Opsのメンバ、テスター、プロダクトオーナーも含まれる。そういうチームにがっさりと権限を与えて、彼ら自身に判断してもらいながら、プロジェクトを遂行させる。 　普段プログラムを書いていない人が、現在の流れのはやい技術の世界で正確な指示が出せるはずもない。諦めて、彼らに任せよう。もしかすると、受け身なメンバーを見ていると、任せるのが不安かもしれないが、任せて、メンバーも慣れてくると、生き生きと自分で考えて行動するようになってくる。最初のしばらくの辛抱だ。 　そうやって、自己組織チームができてくると、上の人が判断していた時代と比べても、圧倒的に早く生産的でイノベーティブになることができる。

　任せる方法がわからない場合は、やはりアジャイルコーチをやとって、自己組織チームを構成するようにするとよい。組織的にそれが現在はできないって？ 上に掛け合って実現しちゃえばいい。人事制度がって？変えればいい。やらなければ、生産性が相当わるくなって、チームがやらされムードに支配されてあまり生産的でもイノベーティブにもならないだけだ。

5. 日本の「常識」で考えている
　最後に、私の自戒も込めて。我々はどうしても、制約事項を「日本の常識」で考えてしまい、「これはできない」とか判断してしまいがちだ。しかし、アジャイルは西洋の人が考えたものなので、西洋の人の考え方を学べば、もともとどういう概念でそれが提唱されたか、どういう前提条件があるのかが非常に理解しやすくなる。

　これに関しては今すぐおすすめの解決策はなく、私のブログを読んでぐらいしかないのだが、現在Rochelle Koppさんという専門家の方と共に、そういった考え方を学びやすくする取り組みを始めている。しばしお待ちを。

## ウォーターフォールは何のメリットも無い


サム・グッケンハイマーの一言
　私は DevOpsのエバンジェリストで、それ以前からアジャイル開発をかれこれ１５年ぐらい実施し、導入の支援をしている。私はかつては、日本の環境の制約の中で如何にアジャイル開発のメリットを最大に引き出すか？ということを考えていた。

ウォーターフォールに対する立場も、真っ向から否定するものでもなく、現状もあるし、それに慣れている人もいるし、実際ウォーターフォールでも失敗しない人も居る。だから、人にウォータフォールのメリット・デメリットを聞かれた時も「変化しないものに関してはウォータフォールはいいのかもしれない」と回答していた。

　しかし、そんな考えを吹き飛ばすような事件が先日発生した。

　サム・グッケンハイマーは、マイクロソフトが、アジャイル、そして DevOps 移行したことに関するソートリーダーだ。世界的にも著名で、多くの書籍を執筆し、世界最大のアジャイルカンファレンスでキーノートも務めた。そんな彼が de:code 2016で来日した。その時に数社の顧客訪問を実施し、私も数社のアテンドを手伝った。

f:id:simplearchitect:20160618214227j:plain

　私は彼といろいろ話をして大変勉強になったが、彼が帰国後送ってくれた議事録を読んで、ハンマーを頭で殴られたような衝撃的な一言があった。彼はエンタープライズ系の企業の方から「アジャイルと、ウォータフォールのメリット・デメリットを教えてください」という顧客からの質問に対してこう答えたのだ。

「ウォータフォールは一切メリットがないので止めておきなさい」

普段彼はスーツは着ないがその彼が顧客訪問のためにスーツに身を包んでいたのに、こんなことを顧客に言い放ったのだ。その一文を読んだとき私は「ああ、本当は心の中でそう思っていたんだ、だけど、世間の目だとか、角が立つとか、炎上するのでは？とか仕事がなくなるのでは？とかそういうことを気にして自分は大人の態度とやらをとっていただけじゃないか」と気づいたのだ。つまり、本当の意見をいうことから逃げていたのだ。

自分の本当の心の中
　自分の心の中ではとっくに決着がついている。大規模だと、ウォータフォールしかない、基幹系はウォータフォールだとかいろいろ意見はある。では、所属会社のことで恐縮だが、マイクロソフト以上の大企業が日本のどこにあるのだろうか？マイクロソフトは、アジャイル化を終えて、さらに DevOps ジャーニーを進めている。

マイクロソフトじゃなくても、海外の他のTech系の企業のどこにウォータフォール押しの企業があるだろうか？

　海外で出版されている新しい技術系の本を見ても、アジャイル以降のノウハウがどんどんデファクトの考えになっており、それを実践したときに発生する課題について書かれている。 最近のどの本を見ても「この本ウォータフォールが前提だな」というのは見当たらなくなっている。ソーシャルコーディング等、アジャイルからさらに先の新しいパラダイムのプログラミングの習慣、文化の上に新しいノウハウが構築されている。

　統計を見ても、2015年のVersion One のサーベイを見るとワールドワイドで９５％の企業がアジャイルを導入しているが、日本だと、同年のPMIの統計によると 31%が導入済みに過ぎず、明らかに遅れをとっている。

f:id:simplearchitect:20160529200718j:plain

マイクロソフトの面接での出来事
　私が、マイクロソフトの面接を受けた時にも、自分の現在の２つ上の上司が面接官だった。彼は面接の最初にちょっとびっくりした声で私に聞いた

Tsuyoshi、日本でアジャイル導入があまり進んでないって本当か？

　私は正直に答えた。「そうだよ。特にエンタープライズ系で。スタートアップとか、サービス系だとそうでもないけど」

彼は相当びっくりしていた。別の機会だが、最近ソフトウェアに詳しいアメリカの女性と話した時にウォータフォールの話をしたら「まだ日本ではウォータフォールなんてやってるの！そんなの誰もやってないよ！」と本当に驚いていた。彼女は特にアジャイルや DevOps の専門家とかではない。

ウォータフォールを紐解いてみる
　ここでWikipediaでウォータフォールの項目を改めて調査してみた。定義のところにこんなことが書いてある。

Waterfall model - Wikipedia, the free encyclopedia

ウォータフォール開発モデルは、製造業や建築業に起源をもっている。高度に構造化された物理的な環境特に、あとで、変更があったときに著しく高価になるもしくは不可能になる環境だ。当時、ソフトウェアのフォーマルな開発手法が存在して居なかった。このハードウェアオリエンテドなモデルが、シンプルにソフトウェアに適用されたのだった（過去形）

という説明になっている。ポジティブで公平な記述をピックアップしてもこんな感じだ。

ウォータフォールモデルが向いているのは、スコープが固定されており、プロジェクトが固定的で、確実であり、技術が 明確に理解されているものである。

　今のソフトウェア開発にはとても向くとは思えない特徴になっている。私は２０年以上この業界にいるが、そんなソフトウェア 開発プロジェクトにお目にかかったことがない。

　実際ウォータフォールモデルは、建築とかだと、素晴らしい成果を出しているところもある。私が昔訪問したあるお客さんが 言っていた。「私たちは８０年代に作成したWBSをいまだに現役で使うことができている。でも、ソフトウェアだけはそうはいかないんだよな。」と。

ウォータフォールは起源から異なっていた
　さらにお話をすると、ウォータフォールの起源はどのようなものか？というと、Winston.W.Royceが書いた MANAGING THE DEVELOPMENT OF LARGE SOFTWARE SYSTEMS という論文が起源になっている。しかし、この論文を見ていただければわかるが、この時点でも、成功するためには、繰り返しや行ったり来たりが必要であり、できれば２回繰り返しなさいといったことが書かれている。現在、日本でイメージするウォータフォールは起源の時点から異なるのだ。英語が苦手な人も上記のリンクを見ていただければ絵で描いているのでご確認いただけると思う。

http://image.slidesharecdn.com/holisticproductdevelopment-130312120839-phpapp01/95/holistic-product-development-35-638.jpg?cb=1424666807

　この後国防総省に広まったときに、なぜか「繰り返し」「戻りの線」がカットされて広まったという歴史がある。彼はとても悔しかったそうだが、その意思を受け継いで彼の子供が作ったのが、繰り返し型のRational Unified Process である。 　ちなみにWikipeidaのWaterfallの項目を見ると、その後国防総省は、ウォータフォールを嫌い、イテレーティブで、インクりメンタルな方法に変更したとの記述がある。

ウォータフォールを前提とするのが本当に日本のためだろうか？
　ソフトウェアの専門家だったら、こういう歴史を知っている人も多いだろう。ウォータフォールのメリットを語る人も、こういうことを知らずに言っているのではなく、日本がウォータフォール前提にいろんな制度を作っていることや、要員、メンバーの慣れ、エンプラ系のプログラマのレベル、商習慣、日本文化の不確実性の忌避などの性質を考慮して、日本でやるなら、ウォータフォールで実施することも否定できないという考えを持つのもわかる。

　しかし、これらは、ソフトウェア開発の本質だろいうか？オブジェクト指向以降に生まれた技術を使ってソフトウェア開発を０から、何のしがらみもない状態から開発するとしたら、誰がウォータフォールを選択するのだろうか？そこに利点はあるのだろうか？

　今、時代はDevOpsやマイクロサービスの時代に突入している。リードタイムが短縮されて、１日に１０回も１００回も本番にデプロイできるようなオートメーションがなされたり、データセンターレベルで抽象化が進んで自動回復を行えるまでの環境が出来てる。Infrastrucute as Codeの対応をしている2200台のサーバーのセキュリティパッチをたった一人が１５分で当て終わるような時代だ。

　しかし、日本の特にエンタープライズはいまだウォータフォールで、数か月以上のリードタイムになっている。こんなのでどうやって海外のベンダーと対等に戦うのだろうか？ 　まさに、竹やりで戦闘機と戦っているようなものだ。みんな竹やりの技術を必死に磨いているうちに、海外では、戦闘機でどんどん飛行時間を伸ばして、経験を積んで新たなノウハウを獲得している。

　人や人種の優秀さの問題ではないのだ。今までは内需で、飯を食えたかもしれないけど、本当にそんなのでいいとは思えない。海外の新しい方法、テクノロジーの経験を積んだ企業が乗り込んで来たら国内はむちゃくちゃになってしまう。

　私は人は変えられないと思っている。変えられるのは自分だけ。だから、このチョイスは人次第だと思うし、ウォータフォールを続ける人も特にダメだか、間違っているとは思わない。

方法は二つある。自分たちの「習慣・現状」に新しい考えを合わせるのか、新しい考えに合わせて「習慣・現状」を変えるのか。私は「習慣・現状」を変える方が本質だと思う。敵と戦うときに、余計な重りを背負ってどうやって勝てるのだろう？我々の価値は顧客にバリューを届けることが勝負で、「日本の事情」は誰も考慮してくれないのは当然じゃないだろうか？だから、「重り」を減らす方がよっぽど楽じゃないだろうか？

　だから、自分は、嫌われても、炎上してもいいから、ソフトウェアの専門家として、自分は現在のソフトウェア開発においてはウォータフォールは何のメリットも無いという意見であることを明確にしておきたい。

日本はソフトウェア開発の後進国
ChefのAlexが日本のソフトウェア業界が8年遅れだと言っていた。Samは5年遅れだと言っていた。この差は年々広がっていると思う。経験というのは短縮できない。彼らが戦闘機の経験を積み重ねている間、竹やりの経験を積み重ねても、戦闘機に乗れるわけではない。 　あるとき気づいて戦闘機に乗り始めたとしても、その操作になれるのには、やはり同じだけの経験が必要になってくるだろう。

　私はインターナショナルチームに所属する経験から、日本人が彼らに劣ってるとは思わないのだ。それどころかイケてるところがいっぱいある。仕事を一生懸命やるし、イノベーティブだし、世界に勝てる要素はゴロゴロある。もったいなすぎる。

　自分の素直な気持ちに従うと、なぜ明らかにソフトウェア産業で後進国となっているのに、先進国のことを学び実践しないのだろうか？

インターナショナルチームにいると、同僚がどんどん先に進んでいるのに、日本で足踏みするのは面白くなさすぎる感覚がある。