zero_03/client_lbe/jobs/feature/v2.0.1/revenue_closure_at(3087f70252).md
---



## TODOまとめ
- B__:
  - 締めボタンを作る
    - ✅React:
      - 案件画面に締めアクションのボタンを作る
      - 案件画面に締め状態を表示する（締め日を表示するだけでよかろう）
    - ✅Controller, Routes
      - ✅Programに締めアクションをつくる
    - ✅Model
      - Programを締め日時で更新する（まじでそれだけ）
  - Programに解除機能をつくる（どこを解除するかの知識はこちらに全て持たせる）
    - ✅React:
      - SuperUserにだけ表示
        - 案件画面に締め解除アクションのボタンを作る
    - ✅Controller, Routes
      - Programに締め解除アクションをつくる
    - ✅Model
      - ✅#revenue_open
      - ✅transaction処理
- β__: 管理案件の画面に「締め処理完了時刻」または「not closed」を表示する
  - ✅fetch: なし
  - ✅sync: Programから revenue_closure_at をコピーする
  - ✅React: 管理案件の画面に「締め処理完了時刻」または「not closed」を表示する
- β2_:
  - ✅Manage::Programにis_finalized: boolean を追加する
  - ✅Finalize処理を追加する
  - ✅FinalizeValidation
  - ✅Sync処理を修正する
  - ✅RevenueOpenの処理を修正する

## 案
### β2
- 方針
  - syncの責務とcloseの責務をごっちゃにしない
  - syncの責務に影響させない
  - closeの処理で、closeさせる
- アイデア
  - Programについて、締め処理したことの記録
  - Programについて、締め処理も取り込んだから、finalize済みだよの記録（is_finalized）
- is_finalizedの取り扱い
  - Fetch→Sync→Finalizeの順序
  - Syncの処理
    - Program#is_finalizedがtrueなら、更新対象外にする
    - Manage::Program#is_finalizedがtrueなら、更新対象外にする
  - Finalizeの処理
    - 締め処理済みなら、is_finalizedをtrueにする
    - 締め処理済みでないなら、 is_finalizedを更新しない


## ボツ
- β++:
  - 1. 締め処理の影響を受ける以下の対象モデルに、 revenue_closed_at を追加する
    - 対象モデル
      - Manage::Program
      - Manage::ProgramDirectCost
      - Manage::ProgramEmployee
  - 2. revenue_openに対象モデルを追加する
  - 3. sync処理
    - revenue_closed_at が
      - presentの場合(締め処理済み)
        - 更新させない
      - nilの場合(締め処理未実施)
        - 更新させる
    - ❌新規作成の場合
      - Manage::Programの場合: なにも気にせずに作成する
      - 🤔それ以外の場合: 親であるManage::Program#revenue_closure_atと比較して、それより後ろなら作成しない
        - なにと比較するつもり？
- ⛔️β#: 締め処理済みなのに、fetchにより作られる内容と異なる場合は、自身とfetchにviolationフラグを立てておく


## 仕様
### 当初の仕様
- B 締めボタンを作る
  - 一度押すと、解除できない（念の為「解除できませんよ？」のアラートを出して、押し間違いを防ぐ）
  - 解除は、super userに依頼すれば可能にする（現在は、北さん、古賀さん、坂田さん、ゼロイチの４名）
- β: 同期処理
  - 締め処理に関係なく同期収集するが、画面には「締め処理完了」ないし「未締め処理」とか「集計中」などの表示を出す

### 仕様への反論
この仕様ではだめだ。
締め処理をしたあと、lbe_system上でのデータ変更を受け付けない仕組みがめんどくさい
少なくとも、他のシステムは更新できてしまうからザルである。

### 問題の核心
- Bは、問題ない。
  - ただの意思表示でしかない。
  - 実際に、更新されてしまうことを、防げないからだ。
- βに、工夫が必要

### βの検討
パターンを挙げよう。

- 締め処理をしていないとき、「未対応」として同期する
- 締め処理をしたときは、「締め処理完了」として同期する
- 締め処理をしているのに、fetchデータに変化があるときは、「違反」として、同期しない。fetchデータとManage::Programに「違反」を記録する。
- 締め処理をしていて、fetchデータに変化がないときは、同期しない。

### より楽な仕様を考えよう
実装工数が大きくなってしまう...
大事なことは「データの確定」である。
しかし、「データの確定」は、システムの外に影響するため、不可能である。
お作法としては、システム外の影響を、システム内に取り込み時に、弾くことである。

しかし、各種データは、案件と紐づいているか？の検証に、手間がかかる。
mf経費の場合、経費明細が変わっていることに気がつくためには、その経費明細の取り込み先の案件と、その案件の元案件の、....大変。

逆に考える。
「案件をロックすると、各種fetchデータがロックされる」でどうだろうか？
ロックされた各種fetchデータと、新たにfetchしたデータが異なる場合は、無断で更新されているということで、違反を見つけられる。
ロックされていないfetchデータは、更新されれば、よい。

### 問題の問題
案件からfetchデータまでの距離が遠い
fetchから案件まですぐに行ければ、ロックできるのでは？

### まとめ
#### Bβバージョン
- B 締めボタンを作る
  - 一度押すと、解除できない（念の為「解除できませんよ？」のアラートを出して、押し間違いを防ぐ）
  - 解除は、super userに依頼すれば可能にする（現在は、北さん、古賀さん、坂田さん、ゼロイチの４名）
    - 解除は、domainで、こちらとあちらを解除しに動くこと
- β: 同期処理
  - 締め処理に関係なく同期収集するが、画面には「締め処理完了」ないし「未締め処理」とか「集計中」などの表示を出す

▼Bβバージョン
締め処理された案件において、fetchしてくる各種データがロックされていないため、こっそり変更された場合は「締めました」という報告がウソになり、締めたはずのデータがこっそり更新されてしまう。
LbEシステム内部で「締め処理」をしても、LbEシステム外部での変更を防ぐことができないために起こるため、LbEシステム内部だけロックしても仕方がない。

#### β'バージョン
- β': 同期処理
  - LbEシステムに取り込む際に、各種データをValidateする。
    - 新規のfetchデータ： validation なしで取り込む
    - 既存のfetchデータ
      - 以前の同期で、すでに締め処理されているデータの場合: 締めた状態なので無視する
        - 以前のfetchデータと、今回のfetchデータに差異があった場合： fetchデータに「違反」を記録する（あとで、管理案件から見つけられる？）
      - 以前の同期で、まだ締め処理されていないデータの場合:
        - 今回もまだ締め処理されていない場合： そのまま取り込んで更新する
        - 今回は締め処理された場合： そのまま取り込んで更新する

▼β'バージョンの限界
仮に、
- 📌PMが12/05に案件を作成し、多少のデータを入れて、
- 📌北さんが12/10に同期と閲覧をしたあと
- 📌PMが12/15に締め処理をしてから
- 📌北さんが12/18に同期をせずに閲覧し、
- 📌PMが12/23にデータを変更して、
- ✅北さん12/25に同期をした場合、
システムは、23日のデータ更新に気づくことができない。

しかし、北さんから見ると、23日時点では「そもそも締め処理をしていない」という認識である。
なお、12/18の閲覧時に、同期もしていた場合は、PMの23日のデータ更新については、25日には取り込まれず、違反判定を食らう。
このときの北さんの認識では「18日時点では、締め処理は済んでいる」という認識である。

▼β''バージョン
この限界すら許せない場合は、締め処理日時とfetchしてくるデータの更新日時を比較して、どちらが前か後かで、違反判定をすることになる。
起こり得るケースと、その影響度と工数のバランスからいって、β'バージョンまでで十分だろう。

#### β'バージョンより軽いβ++
- fetchデータまでは許容する。それが各種システムのデータのミラーだからである。
- fetchデータから、分析データへ同期する際に、β'と同様の処理にする。
- 新規のdirect_cost: validation なしで取り込む
- 既存のdirect_cost:
  - 以前の同期で、すでに締め処理されているデータの場合: 締めた状態なので無視する
    - 計算上、以前のdirect_costと、今回のdirect_costに差異があった場合： direct_costに「違反」を記録する（あとで、管理案件から見つけられる）
    - しかし、この処理はそもそもスキップしたほうが作りやすいので、スキップする
  - 以前の同期で、まだ締め処理されていないデータの場合:
    - 今回もまだ締め処理されていない場合： そのまま取り込んで更新する
    - 今回は締め処理された場合： そのまま取り込んで更新する

前回の締め処理でどうだったか？が大事。

こんな感じだな
```ruby
next if direct_cost.revenue_closed?

direct_cost.assign_attributes(**direct_cost_params)
direct_cost.save
```

あるいは、エラー検知するなら
```ruby
if direct_cost.revenue_closed?
  if direct_cost == new_direct_cost
    next
  else
    direct_cost.update(is_revenue_closed_violation: true)
  end
end

direct_cost.assign_attributes(**direct_cost_params)
direct_cost.save
...

